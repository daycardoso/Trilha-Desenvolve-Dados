# Python by DayCardoso

# Linguagem de programa√ß√£o Python

### ****O que √© Python?****

Descubra o que √© a linguagem de programa√ß√£o Python e como ela pode ser usada.

- Python √© uma linguagem de programa√ß√£o de alto n√≠vel. √â f√°cil de aprender e tem uma sintaxe simples, o que a torna uma √≥tima linguagem para iniciantes.
- Python √© usado para tarefas como web development, machine learning, data science, e muito mais.
- √â compat√≠vel com sistemas operacionais como Windows, Mac OS e Linux.
- Python tem bibliotecas poderosas que permitem que os programadores criem programas complexos rapidamente.
- Python tamb√©m tem frameworks como Django e Flask, que permitem que os programadores criem aplicativos web rapidamente.
- Python √© uma¬†**linguagem interpretada**.¬†***Interpretado***¬†significa que n√£o h√° um processo de compila√ß√£o que traduz o c√≥digo fonte em algum c√≥digo nativo, que o seu computador entende. A¬†[documenta√ß√£o do Python](https://docs.python.org/3/glossary.html)¬†confirma isso, no entanto tamb√©m menciona a presen√ßa de um compilador:
    
    > ***"Python is an interpreted language, as opposed to a compiled one, though the distinction can be blurry because of the presence of the bytecode compiler."***
    > 
    
    > Traduzido livremente:¬†**"Python √© uma linguagem interpretada, em oposi√ß√£o √†s compiladas, embora a distin√ß√£o possa ficar desfocada devido √† presen√ßa do compilador de bytecode."**
    > 

### Opera√ß√µes Escalares

| Opera√ß√£o | Operador | Exemplo |
| --- | --- | --- |
| Adi√ß√£o | + | 2 + 2 = 4 |
| Subtra√ß√£o | - | 4 - 2 = 2 |
| Multiplica√ß√£o | * | 2 * 2 = 4 |
| Divis√£o | / | 10 / 2 = 5 |
| M√≥dulo | % | 11 % 5 = 1 |
| Exponencia√ß√£o | ** | 2 ** 3 = 8 |
| Divis√£o inteira | // | 3 // 2 = 1 |

### Operadores Relacionais

| Significado | Operador |
| --- | --- |
| Igual a | == |
| Diferente de | != |
| Maior que | > |
| Menor que | < |
| Maior ou igual que | >= |
| Menor ou igual que | <= |

### Operadores l√≥gicos

| Significado | Operador | Sintaxe |
| --- | --- | --- |
| E | and | x and y |
| OU | or | x or y |
| Negado | not | not x |

### Tipos de Vari√°veis

<aside>
üí° O Python utiliza por conven√ß√£o o padr√£o¬†***Snake_Case***¬†para nomes de vari√°veis (ou identificadores).

Um exemplo de vari√°veis em¬†***Snake_Case***¬†s√£o:

```python
idade_esposa = 20
perfil_vip = 'Fl√°vio Almeida'
recibos_em_atraso = 30
```

</aside>

| Tipo de Vari√°vel | Formato | Sintaxe | Exemplo |
| --- | --- | --- | --- |
| Inteiro (int) | N√∫meros Inteiros | x = int(5) | x = 5 |
| Ponto Flutuante ou Decimal (float) | N√∫meros Decimais | x = float(3.14) | x = 3.14 |
| Complexo (complex) | N√∫meros Complexos | x = complex(1j) | x = 1j |
| String (str) | Sequ√™ncias de Caracteres | x = str("Hello World") | x = "Hello World" |
| Boolean (bool) | Valores Verdadeiro ou Falso | x = bool(True) | x = True |
| Listas (list) | Sequ√™ncias Mut√°veis | x = list(["Apple", "Banana", "Cherry"]) | x = ["Apple", "Banana", "Cherry"] |
| Tuplas (tuple) | Sequ√™ncias Imut√°veis | x = tuple(("Apple", "Banana", "Cherry")) | x = ("Apple", "Banana", "Cherry") |
| Dicion√°rios (dict) | Cole√ß√µes N√£o-Ordenadas | x = dict({"name": "John", "age": 36}) | x = {"name": "John", "age": 36} |

### Tabela de Formata√ß√£o de Num√©rica

Python possui um m√©todo simples e intuitivo para formatar n√∫meros. O m√©todo `format()` pode ser usado para formatar os n√∫meros para v√°rios fins, como mostrado na tabela a seguir:

| Formato | Descri√ß√£o |
| --- | --- |
| {:f} | Formata o n√∫mero como um n√∫mero de ponto flutuante com o n√∫mero padr√£o de casas decimais. |
| {:.2f} | Formata o n√∫mero como um n√∫mero de ponto flutuante com 2 casas decimais. |
| {:.3f} | Formata o n√∫mero como um n√∫mero de ponto flutuante com 3 casas decimais. |
| {:d} | Formata o n√∫mero como um inteiro. |
| {:x} | Formata o n√∫mero como uma representa√ß√£o hexadecimal. |
| {:b} | Formata o n√∫mero como uma representa√ß√£o bin√°ria. |

**Exemplo**:

```python
numero = 3.14159

print(f"O n√∫mero √© {numero:f}") # O n√∫mero √© 3.141590
print(f"O n√∫mero √© {numero:.2f}") # O n√∫mero √© 3.14
print(f"O n√∫mero √© {numero:.3f}") # O n√∫mero √© 3.142
print(f"O n√∫mero √© {numero:d}") # O n√∫mero √© 3
print(f"O n√∫mero √© {numero:x}") # O n√∫mero √© b.a
print(f"O n√∫mero √© {numero:b}") # O n√∫mero √© 11.1001000010101111111010100001010

```

### Fun√ß√µes Trigonom√©tricas

A seguir, est√° uma tabela das principais fun√ß√µes trigonom√©tricas em Python.

| Fun√ß√£o | Descri√ß√£o | Sintaxe |
| --- | --- | --- |
| sin | Seno | np.sin(x) |
| cos | Cosseno | np.cos(x) |
| tan | Tangente | np.tan(x) |
| arcsin | Seno inverso | np.arcsin(x) |
| arccos | Cosseno inverso | np.arccos(x) |
| arctan | Tangente Inversa | np.arctan(x) |
| sinh | Seno hiperb√≥lico | np.sinh(x) |
| cosh | Cosseno hiperb√≥lico | np.cosh(x) |
| tanh | Tangente hiperb√≥lica | np.tanh(x) |
| arcsinh | Seno hiperb√≥lico inverso | np.arcsinh(x) |
| arccosh | Cosseno hiperb√≥lico inverso | np.arccosh(x) |
| arctanh | Tangente hiperb√≥lica inverso | np.arctanh(x) |
| radians | Converte de graus para radianos | np.radians(x) |
| degrees | Converte de radianos para graus | np.degrees(x) |

## Principais Built-in Functions

| Fun√ß√£o | Descri√ß√£o | Sintaxe B√°sica |
| --- | --- | --- |
| abs() | Retorna o valor absoluto de um n√∫mero | abs(x) |
| aiter() | Retorna um iterador de async | aiter(x) |
| all() | Retorna se todos os elementos s√£o verdadeiros ou se a cole√ß√£o est√° vazia | all(iterable) |
| any() | Retorna se qualquer elemento √© verdadeiro ou se a cole√ß√£o est√° vazia | any(iterable) |
| anext() | Retorna o pr√≥ximo valor de um iterador de async | anext(iterator[, default]) |
| ascii() | Retorna uma representa√ß√£o de string de objetos | ascii(obj) |
| bin() | Retorna a representa√ß√£o bin√°ria de um inteiro | bin(x) |
| bool() | Retorna o valor booleano de um objeto | bool([x]) |
| breakpoint() | Entra em um modo de depura√ß√£o | breakpoint() |
| bytearray() | Retorna um array de bytes mut√°vel | bytearray(source[, encoding[, errors]]) |
| bytes() | Retorna um array de bytes imut√°vel | bytes(source[, encoding[, errors]]) |
| callable() | Retorna se um objeto √© cham√°vel | callable(obj) |
| chr() | Retorna um string de caractere de um inteiro | chr(i) |
| classmethod() | Retorna um m√©todo de classe | classmethod(function) |
| compile() | Compila o c√≥digo em um objeto de c√≥digo | compile(source, filename, mode[, flags[, dont_inherit]]) |
| complex() | Retorna um n√∫mero complexo | complex([real[, imag]]) |
| delattr() | Deleta um atributo de um objeto | delattr(object, name) |
| dict() | Cria um dicion√°rio | dict(**kwarg) |
| dir() | Retorna uma lista de atributos e m√©todos de um objeto | dir([object]) |
| divmod() | Retorna a divis√£o inteira e o resto de dois n√∫meros | divmod(a, b) |
| enumerate() | Retorna um iterador de tuplas contendo √≠ndice e valor | enumerate(iterable[, start]) |
| eval() | Avalia um express√£o | eval(expression[, globals[, locals]]) |
| exec() | Executa c√≥digo de Python | exec(object[, globals[, locals]]) |
| filter() | Retorna um filtro de um iter√°vel | filter(function, iterable) |
| float() | Retorna um float de um n√∫mero ou string | float([x]) |
| format() | Retorna uma string formatada | format(value[, format_spec]) |
| frozenset() | Retorna um conjunto imut√°vel | frozenset(iterable) |
| getattr() | Retorna o valor de um atributo de um objeto | getattr(object, name[, default]) |
| globals() | Retorna o dicion√°rio global | globals() |
| hasattr() | Retorna se um atributo existe em um objeto | hasattr(object, name) |
| hash() | Retorna o valor de hash de um objeto | hash(object) |
| help() | Exibe a documenta√ß√£o de um objeto | help([object]) |
| hex() | Retorna a representa√ß√£o hexadecimal de um inteiro | hex(x) |
| id() | Retorna o identificador √∫nico de um objeto | id(object) |
| input() | Leitura de dados de entrada | input([prompt]) |
| int() | Retorna um inteiro de um n√∫mero ou string | int([x[, base]]) |
| isinstance() | Retorna se um objeto √© uma inst√¢ncia de uma classe | isinstance(object, classinfo) |
| issubclass() | Retorna se uma classe √© subclasse de outra | issubclass(class, classinfo) |
| iter() | Retorna um iterador | iter(object[, sentinel]) |
| len() | Retorna o tamanho de um objeto | len(s) |
| list() | Retorna uma lista de um iter√°vel | list(iterable) |
| locals() | Retorna um dicion√°rio contendo vari√°veis locais | locals() |
| map() | Retorna um mapa de um iter√°vel | map(function, iterable) |
| max() | Retorna o maior elemento de um iter√°vel | max(iterable[, *args[, key]]) |
| memoryview() | Retorna uma vis√£o de mem√≥ria de um objeto | memoryview(obj) |
| min() | Retorna o menor elemento de um iter√°vel | min(iterable[, *args[, key]]) |
| next() | Retorna o pr√≥ximo elemento de um iterador | next(iterator[, default]) |
| object() | Retorna um novo objeto | object() |
| oct() | Retorna a representa√ß√£o octal de um inteiro | oct(x) |
| open() | Retorna um arquivo | open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) |
| ord() | Retorna o inteiro Unicode de um caractere | ord(c) |
| pow() | Retorna o resultado de x elevado a y | pow(x, y[, z]) |
| print() | Imprime os argumentos na sa√≠da padr√£o | print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False) |
| property() | Retorna um propriedade de um objeto | property(fget=None, fset=None, fdel=None, doc=None) |
| range() | Retorna um sequ√™ncia de n√∫meros | range(start, stop[, step]) |
| repr() | Retorna uma representa√ß√£o de string de um objeto | repr(object) |
| reversed() | Retorna um iterador reverso | reversed(sequence) |
| round() | Retorna um n√∫mero arredondado | round(number[, ndigits]) |
| set() | Retorna um conjunto de um iter√°vel | set(iterable) |
| setattr() | Define um atributo de um objeto | setattr(object, name, value) |
| slice() | Retorna um slice de um objeto | slice(start, stop[, step]) |
| sorted() | Retorna uma lista ordenada de um iter√°vel | sorted(iterable[, key][, reverse]) |
| staticmethod() | Retorna um m√©todo est√°tico | staticmethod(function) |
| str() | Retorna uma string de um objeto | str(object='') |
| sum() | Retorna a soma de elementos de um iter√°vel | sum(iterable[, start]) |
| super() | Retorna um objeto proxy para superclasses | super([type[, object-or-type]]) |
| tuple() | Retorna uma tupla de um iter√°vel | tuple(iterable) |
| type() | Retorna o tipo de um objeto | type(object) |
| vars() | Retorna o dicion√°rio de vari√°veis de um objeto | vars([object]) |
| zip() | Retorna um iterador de tuplas | zip(*iterables) |
| import() | Importa um m√≥dulo | import(name[, globals[, locals[, fromlist[, level]]]]) |

## Imprimir

Imprime os valores em um fluxo ou em sys.stdout por padr√£o.

```python
print(*args, sep=' ', end='\n', file=None, flush=False)
```

`set`string inserido entre valores, padr√£o um espa√ßo.
`end`string acrescentado ap√≥s o √∫ltimo valor, o padr√£o √© uma nova linha.
`file`um objeto tipo arquivo (stream); o padr√£o √© o sys.stdout atual.
`flush`se for√ßar a descarga do fluxo

### Interpola√ß√£o de String em Python

A interpola√ß√£o de strings √© uma pr√°tica comum na programa√ß√£o que permite aos programadores inserir vari√°veis em strings usando sintaxe simples e intuitiva. Isso √© muito √∫til para criar strings de sa√≠da personalizadas com dados de entrada.

No Python, a interpola√ß√£o de strings √© feita usando a sintaxe `f-string`. Esta √© uma maneira concisa e poderosa de adicionar vari√°veis √†s strings. A sintaxe √© simples: basta inserir o nome da vari√°vel dentro de chaves `{}` dentro da string, como mostrado abaixo.

```python
nome = "Jo√£o"
print(f"Ol√°, {nome}!") # Ol√°, Jo√£o!
```

A interpola√ß√£o de strings tamb√©m pode ser usada para formatar n√∫meros e datas usando o m√©todo `format()`. Por exemplo, para formatar um n√∫mero decimal para ter 3 casas decimais, voc√™ pode usar o seguinte c√≥digo:

```python
numero = 3.14159
print(f"O n√∫mero √© {numero:.3f}") # O n√∫mero √© 3.142
```

A interpola√ß√£o de strings √© uma t√©cnica √∫til que pode ajudar a tornar seu c√≥digo mais leg√≠vel e conciso. √â uma pr√°tica comum utilizada por programadores experientes e vale a pena aprender.

## Como Importar Bibliotecas em Python

O Python possui um enorme conjunto de bibliotecas pr√©-instaladas que podem ser usadas para realizar tarefas espec√≠ficas. Essas bibliotecas incluem m√≥dulos, classes, fun√ß√µes e outras vari√°veis que podem ser usadas para realizar tarefas espec√≠ficas. Para usar uma biblioteca, ela primeiro precisa ser importada no programa.

O Python possui diversos m√©todos para importar bibliotecas, tais como:

- **`import`** - Esta √© a forma mais simples de importar uma biblioteca. Esta sintaxe importa todo o conte√∫do da biblioteca para o seu programa. Sintaxe:

```python
import nome_da_biblioteca

# Exemplo:

import pandas

```

- **`from`** - Esta sintaxe permite importar apenas partes espec√≠ficas de uma biblioteca, como m√≥dulos, classes ou fun√ß√µes. Sintaxe:

```python
from nome_da_biblioteca import nome_do_modulo

# Exemplo:

from pandas import DataFrame

```

- **`as`** - Esta sintaxe permite dar um novo nome √† biblioteca importada. Isso √© √∫til se voc√™ quiser usar uma abreviatura para a biblioteca. Sintaxe:

```python
import nome_da_biblioteca as abreviatura

# Exemplo:

import pandas as pd

```

Com esses m√©todos, voc√™ pode importar qualquer biblioteca necess√°ria para o seu programa e come√ßar a aplicar seu conhecimento.

## Como Definir uma Fun√ß√£o em Python

Em Python, uma fun√ß√£o √© definida usando a palavra-chave `def` seguida do nome da fun√ß√£o e de par√™nteses contendo os par√¢metros. Os par√¢metros s√£o vari√°veis que ser√£o usadas dentro da fun√ß√£o. A sintaxe b√°sica √© a seguinte:

```python
def nome_da_fun√ß√£o(parametros):
    declara√ß√µes

```

**Exemplo**:

```python
def soma(a, b):
    return a + b

```

No exemplo acima, a fun√ß√£o `soma()` recebe dois par√¢metros `a` e `b` e retorna a soma deles. A fun√ß√£o pode ent√£o ser chamada passando dois n√∫meros como argumentos.

```python
resultado = soma(2, 3)

# Sa√≠da:
# 5

```

Al√©m disso, as fun√ß√µes podem ter argumentos opcionais, que s√£o argumentos que podem ou n√£o ser passados para a fun√ß√£o.

```python
def soma(a, b, c=0):
    return a + b + c

```

No exemplo acima, a fun√ß√£o `soma()` tem um argumento opcional `c`. Se nenhum valor for passado para `c`, o valor padr√£o ser√° 0.

```python
resultado = soma(2, 3)

# Sa√≠da:
# 5

```

Com esses conceitos b√°sicos, voc√™ pode definir fun√ß√µes para realizar qualquer tarefa desejada.

## List Comprehension

List Comprehension √© uma ferramenta poderosa que permite aos programadores Python criar listas de forma eficiente. √â uma nota√ß√£o de simplifica√ß√£o que permite que voc√™ crie listas, dicion√°rios e conjuntos usando uma sintaxe concisa. A sintaxe b√°sica de uma List Comprehension √© a seguinte:

```python
[express√£o for item in lista if condi√ß√£o]
```

A **express√£o** √© aplicada a cada **item** da **lista** e √© inserida na nova lista se a **condi√ß√£o** for verdadeira.

Por exemplo, imagine que voc√™ tem uma lista de n√∫meros e quer criar uma nova lista com apenas os n√∫meros pares:

**Exemplo**:

```python
# Cria uma lista de n√∫meros inteiros
inteiros = [1, 2, 3, 4, 5]

# Usando List Comprehension para criar uma lista de n√∫meros ao quadrado
quadrados = [x**2 for x in inteiros]

# Sa√≠da:
# [1, 4, 9, 16, 25]

```

No exemplo acima, a express√£o `x**2` √© aplicada a cada item na lista inteiros, e os resultados s√£o adicionados √† lista quadrados.

- Al√©m disso, tamb√©m √© poss√≠vel usar condicionais para filtrar os resultados:

```python
# Cria uma lista de n√∫meros inteiros
inteiros = [1, 2, 3, 4, 5]

# Usando List Comprehension para criar uma lista de n√∫meros pares
pares = [x for x in inteiros if x % 2 == 0]

# Sa√≠da:
# [2, 4]

```

No exemplo acima, a condicional `x % 2 == 0` √© usada para filtrar os resultados e adicionar apenas os n√∫meros pares √† lista pares.

- List Comprehension tamb√©m √© √∫til para trabalhar com estruturas de dados mais complexas, como dicion√°rios. Por exemplo, imagine que voc√™ tem um dicion√°rio de pessoas e quer criar uma nova lista com apenas os nomes:

```python
pessoas = {
    "Alice": 25,
    "Bob": 30,
    "Charlie": 35
}
nomes = [nome for nome, idade in pessoas.items()]
print(nomes) 

# Sa√≠da:
# ['Alice', 'Bob', 'Charlie']
```

- Um exemplo de List Comprehension mais complexo:

Imagine que voc√™ tem uma lista de strings que representam os nomes de pessoas e outra lista que representa suas idades. E voc√™ quer criar uma lista de dicion√°rios que tenham nome e idade como chaves:

```python
nomes = ["Alice", "Bob", "Charlie", "David"]
idades = [25, 30, 35, 40]
pessoas = [{"nome": nome, "idade": idade} for nome, idade in zip(nomes, idades)]
print(pessoas)
# [{'nome': 'Alice', 'idade': 25},#  {'nome': 'Bob', 'idade': 30},#  {'nome': 'Charlie', 'idade': 35},#  {'nome': 'David', 'idade': 40}]
```

Neste exemplo, usamos a fun√ß√£o **`zip`** para combinar as duas listas **`nomes`** e  **`idades`** em um √∫nico iter√°vel e, em seguida, usamos a List Comprehension para criar a lista de dicion√°rios **`pessoas`**. Observe como a List Comprehension permite que voc√™ crie uma nova estrutura de dados a partir de duas listas diferentes de forma concisa e elegante.

<aside>
<img src="https://www.notion.so/icons/light-bulb_orange.svg" alt="https://www.notion.so/icons/light-bulb_orange.svg" width="40px" /> A List Comprehension √© uma ferramenta vers√°til e poderosa para criar listas em Python. Ela √© muito √∫til para codifica√ß√£o r√°pida e eficiente e para manipula√ß√£o de dados de uma forma concisa e leg√≠vel.

</aside>

## Como Importar um arquivo python para dentro de outro arquivo python?

Python possui um mecanismo para importar arquivos dentro de outros arquivos, conhecido como importa√ß√£o de m√≥dulos. Para importar um arquivo para dentro de outro, voc√™ deve usar o comando `import`. Por exemplo, para importar o arquivo `arquivo.py` em outro arquivo, voc√™ usaria o seguinte comando:

```python
import arquivo

```

Tamb√©m √© poss√≠vel importar apenas partes de um arquivo, usando o comando `from`. Por exemplo, para importar uma fun√ß√£o espec√≠fica do arquivo `arquivo.py`, voc√™ usaria o seguinte comando:

```python
from arquivo import nome_da_fun√ß√£o

```

Se voc√™ deseja importar todas as fun√ß√µes de um arquivo, voc√™ pode usar o seguinte comando:

```python
from arquivo import *

```

√â importante observar que, quando voc√™ importa um arquivo, voc√™ n√£o est√° executando seu c√≥digo. O c√≥digo s√≥ √© executado quando voc√™ chama uma fun√ß√£o ou classe definida no arquivo importado.

# Condicionais em Python 3.11

Uma fun√ß√£o condicional √© um conjunto de regras que informam ao computador como reagir a um determinado conjunto de dados. Em Python, podemos usar as instru√ß√µes condicionais para controlar o fluxo de execu√ß√£o de um programa.

### Lista das fun√ß√µes condicionais

- **`if`** - Esta √© a instru√ß√£o mais comum usada no Python para fazer um teste l√≥gico. Se a condi√ß√£o for verdadeira, ent√£o a declara√ß√£o relacionada √© executada. Sintaxe:
    
    ```python
    if condi√ß√£o:
        declara√ß√£o
    
    #ou:
    
    if(acertou):
        print("Parab√©ns! Voc√™ acertou.")
    ```
    
    **Exemplo**:
    
    ```python
    if x > 0:
      print("x √© positivo")
    ```
    
- **`if-else**` - Esta √© uma estrutura condicional usada para especificar duas poss√≠veis a√ß√µes, uma para quando a condi√ß√£o √© verdadeira e outra para quando ela √© falsa. Sintaxe:
    
    ```python
    if condi√ß√£o:
        declara√ß√£o
    else:
        declara√ß√£o
    ```
    
    **Exemplo**:
    
    ```python
    if x > 0:
      print("x √© positivo")
    else:
      print("x √© negativo")
    ```
    
- **`elif`** - Esta √© uma instru√ß√£o condicional usada para especificar uma s√©rie de poss√≠veis condi√ß√µes e seus respectivos resultados. Sintaxe:
    
    ```python
    if condi√ß√£o:
        declara√ß√£o
    elif condi√ß√£o:
        declara√ß√£o
    ```
    
    **Exemplo**:
    
    ```python
    if x > 0:
      print("x √© positivo")
    elif x < 0:
      print("x √© negativo")
    ```
    
- **`while`** - Esta instru√ß√£o √© usada para especificar um la√ßo de repeti√ß√£o. O la√ßo continua a ser executado enquanto a condi√ß√£o for verdadeira. Sintaxe:
    
    ```python
    while condi√ß√£o:
        declara√ß√£o
    ```
    
    **Exemplo**:
    
    ```python
    while x > 0:
      print("x √© positivo")
      x = x - 1
    ```
    
- **`For` -** Instru√ß√£o de repeti√ß√£o usada para iterar sobre sequ√™ncias, como listas, tuplas ou strings. Ele permite que o programador execute uma ou mais instru√ß√µes em cada item da sequ√™ncia. Sintaxe:
    
    ```python
    for item in sequ√™ncia:
        declara√ß√£o
    #Onde item √© uma vari√°vel que ir√° receber cada item da sequ√™ncia na cada itera√ß√£o do la√ßo, e sequ√™ncia √© a lista, string, tupla ou outra estrutura de dados que deseja iterar.
    ```
    
    **Exemplo**:
    
    ```
    lista = [1, 2, 3, 4]
    
    for item in lista:
      print(item)
    
    # Sa√≠da:
    # 1
    # 2
    # 3
    # 4
    ```
    
    ### Exemplo usando for e `range()`
    
    O la√ßo `for` pode ser usado com a fun√ß√£o `range()` para iterar sobre um intervalo de n√∫meros. A fun√ß√£o `range()` recebe um n√∫mero inteiro como par√¢metro e retorna uma sequ√™ncia de n√∫meros inteiros dentro do intervalo especificado. A sintaxe b√°sica √© a seguinte:
    
    ```python
    range(in√≠cio, fim, passo)
    ```
    
    `in√≠cio` √© opcional e, se n√£o for especificado, o `range()` come√ßar√° no 0.
    
    `fim` √© obrigat√≥rio e especifica o n√∫mero final da sequ√™ncia (n√£o inclu√≠do).
    
    `passo` √© opcional e, se n√£o for especificado, o `range()` usar√° um passo de 1.
    
    **Exemplo**:
    
    ```python
    for contador in range(1, 11):
        print(contador)
    
    # Sa√≠da:
    # 0
    # 1
    # 2
    # 3
    # 4
    # 5
    # 6
    # 7
    # 8
    # 9
    #10
    ```
    
    No exemplo acima, a fun√ß√£o `range()` foi chamada com o par√¢metro `10`, o que resultou em uma sequ√™ncia de n√∫meros inteiros de 0 a 9. Esta sequ√™ncia foi ent√£o usada pelo la√ßo `for` para iterar sobre os n√∫meros, imprimindo cada n√∫mero na tela.
    
    ### Diferen√ßas entre `Break` e `Continue`
    
    Break e continue s√£o dois comandos usados para controlar o fluxo de um programa. O break interrompe a execu√ß√£o do programa e sai do loop atual, enquanto o continue causa a interrup√ß√£o da itera√ß√£o atual, mas o loop continua.
    
    **Exemplos**:
    
    `Break`
    
    ```python
    for i in range(10):
        if i == 5:
            break
        print(i)
    
    # Sa√≠da:
    # 0
    # 1
    # 2
    # 3
    # 4
    
    ```
    
    `Continue`
    
    ```python
    for i in range(10):
        if i == 5:
            continue
        print(i)
    
    # Sa√≠da:
    # 0
    # 1
    # 2
    # 3
    # 4
    # 6
    # 7
    # 8
    # 9
    ```
    
    <aside>
    üí° Como voc√™ pode ver no exemplo acima, o `break` interrompeu a execu√ß√£o do la√ßo ao encontrar o n√∫mero 5, enquanto o `continue` ignora o n√∫mero 5 e continua a itera√ß√£o do la√ßo.
    
    </aside>
    

# Orienta√ß√£o a Objeto

Orienta√ß√£o a objeto √© um paradigma de programa√ß√£o que se baseia na representa√ß√£o da realidade atrav√©s de objetos e na manipula√ß√£o desses objetos para resolver problemas. Em Python, voc√™ pode usar a orienta√ß√£o a objeto para modelar a realidade de forma mais abstrata, organizada e reutiliz√°vel.

Em Python, um objeto √© uma inst√¢ncia de uma classe. Uma classe √© uma defini√ß√£o de um objeto, que descreve seus atributos (ou caracter√≠sticas) e comportamentos (ou a√ß√µes). Por exemplo, voc√™ pode criar uma classe **`Pessoa`** que tenha atributos como **`nome`**, **`idade`** e **`altura`** e comportamentos como **`caminhar`** e **`falar`**.

A sintaxe b√°sica de uma classe em Python √©:

```python
class NomeDaClasse:
  # Construtor (opcional)
  def __init__(self, argumentos):
    # Inicializa√ß√£o dos atributos
    self.atributo1 = argumentos

  # M√©todos (opcionais)
  def metodo1(self, argumentos):
    # Instru√ß√µes do m√©todo
```

Onde **`NomeDaClasse`** √© o nome da classe, **`argumentos`** s√£o os argumentos do construtor (opcionais), **`atributo1`** √© o nome de um atributo e **`metodo1`** √© o nome de um m√©todo.

Exemplo:

```python
class Pessoa:
  def __init__(self, nome, idade, altura):
    self.nome = nome
    self.idade = idade
    self.altura = altura

  def caminhar(self):
    print(self.nome + " est√° caminhando.")

  def falar(self, mensagem):
    print(self.nome + " diz: " + mensagem)
```

Voc√™ pode criar objetos a partir da classe usando o seguinte c√≥digo:

```python
pessoa1 = Pessoa("John", 30, 1.75)
pessoa2 = Pessoa("Jane", 25, 1.60)
```

Voc√™ pode acessar os atributos e chamar os m√©todos dos objetos:

```python
print(pessoa1.nome)
pessoa1.caminhar()
pessoa1.falar("Ol√°, mundo!")
```

A sa√≠da seria:

```powershell
John
John est√° caminhando.
John diz: Ol√°, mundo!
```

### Heran√ßa

Em Python, √© poss√≠vel herdar de uma classe existente para criar uma nova classe com as mesmas caracter√≠sticas e comportamentos, acrescentando ou modificando atributos e m√©todos conforme necess√°rio. Para isso, voc√™ precisa incluir o nome da classe pai na defini√ß√£o da nova classe, como mostrado abaixo: 

```python
class Filha(Pai):
  # Construtor (opcional)
  def __init__(self, argumentos):
    # Inicializa√ß√£o dos atributos
    Pai.__init__(self, argumentos)
    self.atributo_filha = argumentos

  # M√©todos (opcionais)
  def metodo_filha(self, argumentos):
    # Instru√ß√µes do m√©todo
```

Neste exemplo, a classe **`Filha`** herda da classe **`Pai`** e pode acessar todos os atributos e m√©todos da classe pai, al√©m de incluir um novo atributo **`atributo_filha`** e um novo m√©todo **`metodo_filha`**.

Al√©m disso, em Python √© poss√≠vel usar o conceito de sobrecarga de m√©todos (overloading) para for√ßar uma classe filha a sobrescrever um m√©todo da classe pai. Para isso, voc√™ precisa incluir um m√©todo com o mesmo nome na classe filha, como mostrado abaixo:

```python
class Filha(Pai):
  # Construtor (opcional)
  def __init__(self, argumentos):
    # Inicializa√ß√£o dos atributos
    Pai.__init__(self, argumentos)
    self.atributo_filha = argumentos

  # M√©todos (opcionais)
  def metodo_filha(self, argumentos):
    # Instru√ß√µes do m√©todo
  def metodo_pai(self, argumentos):
    # Instru√ß√µes do m√©todo
    # Sobrescrita do m√©todo pai
```

Neste exemplo, a classe **`Filha`** sobrescreve o m√©todo **`metodo_pai`** da classe **`Pai`**. Quando voc√™ criar um objeto a partir da classe **`Filha`** e chamar o m√©todo **`metodo_pai`**, as instru√ß√µes da classe filha ser√£o executadas.

Heran√ßa √© um conceito fundamental da orienta√ß√£o a objetos e permite a reutiliza√ß√£o de c√≥digo. No exemplo que mencionei anteriormente, podemos criar uma classe **`Estudante`** que herda da classe **`Pessoa`**. A classe **`Estudante`** ter√° as mesmas caracter√≠sticas (nome, idade e altura) e comportamentos (caminhar e falar) da classe **`Pessoa`**, al√©m de novos atributos e m√©todos espec√≠ficos de um estudante.

A sintaxe para herdar de uma classe em Python √©:

```python
class Estudante(Pessoa):
    def __init__(self, nome, idade, altura, matricula, curso):
        Pessoa.__init__(self, nome, idade, altura)
        self.matricula = matricula
        self.curso = curso
```

Neste exemplo, a classe **`Estudante`** est√° herdando da classe **`Pessoa`**. O construtor **`__init__`** da classe **`Estudante`** chama o construtor da classe **`Pessoa`** com **`Pessoa.__init__(self, nome, idade, altura)`** para inicializar os atributos **`nome`**, **`idade`** e **`altura`**. Em seguida, adiciona novos atributos **`matricula`** e **`curso`**.

Assim, todas as caracter√≠sticas e comportamentos da classe **`Pessoa`** estar√£o dispon√≠veis para a classe **`Estudante`**, permitindo que voc√™ crie objetos **`Estudante`** com as informa√ß√µes espec√≠ficas de um estudante e ainda assim utilize os comportamentos da classe **`Pessoa`**.

```python
estudante = Estudante("Jo√£o", 22, 1.75, "1234567", "Ci√™ncia da Computa√ß√£o")
estudante.caminhar()
estudante.falar()
```

Neste exemplo, estamos criando um objeto **`estudante`** da classe **`Estudante`** e chamando os m√©todos **`caminhar`** e **`falar`** da classe **`Pessoa`**, mesmo que esses m√©todos n√£o tenham sido explicitamente definidos na classe **`Estudante`**.

### Polimorfismo

Polimorfismo √© um conceito importante da orienta√ß√£o a objetos que permite que objetos de diferentes classes compartilhem o mesmo comportamento. Em Python, voc√™ pode usar polimorfismo para criar fun√ß√µes e m√©todos gen√©ricos que podem trabalhar com objetos de diferentes classes.

Por exemplo, voc√™ pode criar uma fun√ß√£o gen√©rica que aceita qualquer objeto como seu argumento e chama o m√©todo `caminhar()` desse objeto. Se o argumento for um objeto da classe `Pessoa`, a fun√ß√£o chamar√° `Pessoa.caminhar()`. Se o argumento for um objeto da classe `Estudante`, a fun√ß√£o chamar√° `Estudante.caminhar()`.

```
def caminhar(objeto):
    objeto.caminhar()

```

Neste exemplo, a fun√ß√£o `caminhar()` pode ser chamada com qualquer objeto, independentemente de sua classe. A fun√ß√£o chamar√° o m√©todo `caminhar()` do objeto passado como argumento. Assim, ao usar polimorfismo, voc√™ n√£o precisa escrever c√≥digo espec√≠fico para cada classe. Voc√™ s√≥ precisa escrever o c√≥digo uma vez e ele ser√° aplicado a todos os objetos, independentemente de sua classe.

### Diferen√ßa entre Heran√ßa e Polimorfismo

Heran√ßa √© quando voc√™ pode criar classes filhas que herdam atributos e fun√ß√µes do pai. Eles s√£o frequentemente usados quando voc√™ tem uma classe abrangente mais geral, mas deseja definir classes mais espec√≠ficas que podem ser semelhantes, mas n√£o exatamente iguais. Fazemos isso para evitar copiar e colar um zilh√£o de vezes.

Neste exemplo, usamos c√£es como exemplo de como a heran√ßa pode ser usada. Demonstro como criar uma classe pai (superclasse) e uma classe filha (subclasse) e inicializar ambas.

Tamb√©m podemos ter heran√ßa m√∫ltipla, que √© quando uma subclasse pode ter v√°rios pais e herdar as fun√ß√µes e atributos exclusivos de ambos. Um exemplo √© o `ViraLata`!

O polimorfismo est√° relacionado √† heran√ßa. Polimorfismo significa assumir muitas formas. Em OOP, isso geralmente est√° relacionado a subclasses que substituem o m√©todo pai para que a classe mais espec√≠fica possa seguir um conjunto diferente de instru√ß√µes. No meu exemplo, uso diferentes latidos de diferentes ra√ßas de cachorros.

```python
class Cachorro:
    def __init__(self, nome, idade, amigavel):
        self.nome = nome
        self.idade = idade
        self.amigavel = amigavel

    def gosta_de_passear(self):
        # Todo cachorro gosta depassear ent√£o sempre Thrue
        return True 
    
    def latido(self):
        return 'Woooof!'
    
class Caramelo(Cachorro):
    def __init__(self, nome, idade, amigavel):
        super().__init__(nome, idade, amigavel)
        
    def brincalhao(self):
        return "Fiquei esperando o dia todo pra voc√™ brincar comigo!"
    
    def latido(self):
        return 'AuAu Auu!'
    
class GoldenRetriever(Cachorro):
    def __init__(self, nome, idade, amigavel):
        super().__init__(nome, idade, amigavel)
        
    def bagunceiro(self):
        return "Amo fazer uma bagun√ßa, n√£o deixa um chinelo ou uma carteira na minha frente que eu mastigo hahhaha"
    
    #def latido(self):
    #    return 'Hauf hauf hauf!'

class HuskySiberiano(Cachorro):
    def __init__(self, nome, idade, amigavel):
        super().__init__(nome, idade, amigavel)
        
    def barulhento(self):
        return "Eu s√≥ to tentando te contar como foi o meu dia!!"
    
    def latido(self):
        return 'wuff, wuff; wau!'
        
class ViraLata(Caramelo, GoldenRetriever):
    def __init__(self, nome, idade, amigavel):
        super().__init__(nome, idade, amigavel)
        
    def latido(self):
       return 'voff, voff!'
    

bebeto = Caramelo('Bebeto', 3, 10)

print("Seu nome √© {}, ele tem {} anos e seu nivel de amabilidade √© {}/10".format(bebeto.nome, bebeto.idade, bebeto.amigavel))
print("Ele gosta de passear? R: {}".format(bebeto.gosta_de_passear()))

pitchula = ViraLata('Pitchula', 12, 10)

#Note que eu n√£o declarei brincalhao ou bagunceiro em ViraLata mas ele herdou isso dos pais.
print(pitchula.brincalhao(),"\n",pitchula.bagunceiro()) 

lily = GoldenRetriever('Lily', 7, 10)
romeu = HuskySiberiano('Romeu', 5, 10)

# Usando polimorfismo
cachorros = [bebeto, pitchula, romeu, lily]
for raca in cachorros:
    print("Meu nome √© {} e eu fa√ßo {}".format(raca.nome,raca.latido()))
```

### Segue mais dois exemplos para ajudar a entender o conceito de orienta√ß√£o a objeto e heran√ßa em Python:

**1¬∫ Exemplo:**

> Vamos imaginar que temos uma classe chamada **`Animal`** que possui os atributos **`nome`**, **`cor`** e **`idade`** e os m√©todos **`comer`**, **`dormir`** e **`andar`**. Essa classe pode ser usada para criar objetos que representam animais.
> 
> 
> ```python
> class Animal:
>   def __init__(self, nome, cor, idade):
>     self.nome = nome
>     self.cor = cor
>     self.idade = idade
> 
>   def comer(self):
>     print(self.nome + " est√° comendo.")
> 
>   def dormir(self):
>     print(self.nome + " est√° dormindo.")
> 
>   def andar(self):
>     print(self.nome + " est√° andando.")
> 
> ```
> 
> Agora, n√≥s podemos criar um objeto da classe **`Animal`** chamado **`cachorro`**:
> 
> ```python
> cachorro = Animal("Toby", "marrom", 3)
> 
> ```
> 
> E podemos acessar os atributos e chamar os m√©todos deste objeto:
> 
> ```python
> print(cachorro.nome)
> cachorro.comer()
> cachorro.dormir()
> cachorro.andar()
> 
> ```
> 
> A sa√≠da seria:
> 
> ```powershell
> Toby
> Toby est√° comendo.
> Toby est√° dormindo.
> Toby est√° andando.
> 
> ```
> 
> Agora, vamos imaginar que queremos criar um objeto da classe **`Animal`** que represente um cachorro especial, um **`Salsicha`**. Para isso, n√≥s podemos criar uma nova classe chamada **`Salsicha`** que herde da classe **`Animal`** e adicione um novo atributo e um novo m√©todo:
> 
> ```python
> class Salsicha(Animal):
>   def __init__(self, nome, cor, idade, tamanho):
>     Animal.__init__(self, nome, cor, idade)
>     self.tamanho = tamanho
> 
>   def rosnar(self):
>     print(self.nome + " est√° rosnando.")
> 
> ```
> 
> A classe **`Salsicha`** herda da classe **`Animal`**, portanto ela possui todos os atributos e m√©todos definidos na classe **`Animal`**, al√©m de um novo atributo **`tamanho`** e um novo m√©todo **`rosnar`**.
> 
> Agora, podemos criar um objeto da classe **`Salsicha`** chamado **`salsicha`**:
> 
> ```python
> salsicha = Salsicha("Bolota", "branco", 1, "pequeno")
> 
> ```
> 
> E podemos acessar os atributos e chamar os m√©todos deste objeto:
> 
> ```python
> print(salsicha.nome)
> salsicha.comer()
> salsicha.dormir()
> salsicha.andar()
> salsicha.rosnar()
> 
> ```
> 
> A sa√≠da seria:
> 
> ```powershell
> Bolota
> Bolota est√° comendo.
> Bolota est√° dormindo.
> Bolota est√° andando.
> Bolota est√° rosnando.
> 
> ```
> 
> Neste exemplo, a crian√ßa pode entender como a classe **`Salsicha`** herda da classe **`Animal`** e como usar heran√ßa para criar objetos com caracter√≠sticas es
> 

**2¬∞ Exemplo**

> Imagine que voc√™ quer construir um jogo de avatares em que cada avatar tem um nome, uma idade e uma cor de cabelo. Al√©m disso, todos os avatares t√™m a capacidade de se mover e falar.
> 
> 
> Voc√™ pode come√ßar criando uma classe **`Avatar`** que representa os atributos e comportamentos comuns a todos os avatares:
> 
> ```python
> class Avatar:
>     def __init__(self, nome, idade, cor_cabelo):
>         self.nome = nome
>         self.idade = idade
>         self.cor_cabelo = cor_cabelo
> 
>     def mover(self):
>         print(f"{self.nome} est√° se movendo.")
> 
>     def falar(self):
>         print(f"{self.nome} est√° falando.")
> ```
> 
> Em seguida, voc√™ pode criar uma classe **`Crianca`** que herda da classe **`Avatar`** e adiciona um novo atributo, **`altura`**, e um novo comportamento, **`pular`**:
> 
> ```python
> class Crianca(Avatar):
>     def __init__(self, nome, idade, cor_cabelo, altura):
>         Avatar.__init__(self, nome, idade, cor_cabelo)
>         self.altura = altura
> 
>     def pular(self):
>         print(f"{self.nome} est√° pulando.")
> ```
> 
> Agora voc√™ pode criar objetos da classe **`Crianca`** e utilizar seus atributos e comportamentos:
> 
> ```python
> crianca = Crianca("Lara", 7, "loira", 1.20)
> print(crianca.nome) # Lara
> print(crianca.idade) # 7
> print(crianca.cor_cabelo) # loira
> print(crianca.altura) # 1.20
> crianca.mover() # Lara est√° se movendo.
> crianca.falar() # Lara est√° falando.
> crianca.pular() # Lara est√° pulando.
> ```
> 
> Neste exemplo, a classe **`Crianca`** herda todos os atributos e comportamentos da classe **`Avatar`**, al√©m de adicionar um novo atributo e comportamento. Desta forma, voc√™ pode reutilizar o c√≥digo da classe **`Avatar`** e ainda assim ter a flexibilidade de adicionar ou modificar atributos e comportamentos espec√≠ficos da classe **`Crianca`**.
> 

# Collections

No Python, as Collections s√£o estruturas de dados especializadas que permitem armazenar e acessar dados de maneira eficiente. Existem v√°rios tipos de Collections dispon√≠veis no Python, incluindo `listas`, `tuplas`, `dicion√°rios` e `conjuntos`.

Uma **lista** √© uma sequ√™ncia **mut√°vel** de objetos que podem ser acessados usando √≠ndices. √â poss√≠vel adicionar, remover e modificar elementos da lista. Por exemplo, a lista abaixo cont√©m tr√™s elementos:

```python
lista = [1, 2, 3]

```

Uma **tupla** √© semelhante a uma lista, exceto que √© **imut√°vel**. Uma vez criada, uma tupla n√£o pode ser modificada. Por exemplo, a tupla abaixo cont√©m tr√™s elementos:

```python
tupla = (1, 2, 3)

```

Um **dicion√°rio** √© uma estrutura de dados que consiste em **chaves e valores**. Os valores podem ser recuperados usando as chaves. Por exemplo, o dicion√°rio abaixo cont√©m tr√™s elementos:

```python
dicionario = {'a': 1, 'b': 2, 'c': 3}

```

Um **conjunto** √© uma cole√ß√£o **n√£o ordenada de elementos √∫nicos**. Por exemplo, o conjunto abaixo cont√©m tr√™s elementos:

```python
conjunto = {1, 2, 3}

```

<aside>
<img src="https://www.notion.so/icons/light-bulb_orange.svg" alt="https://www.notion.so/icons/light-bulb_orange.svg" width="40px" /> As Collections do Python permitem armazenar de forma eficiente e organizada diferentes tipos de dados. Elas s√£o essenciais para muitas tarefas de programa√ß√£o, desde a manipula√ß√£o de dados at√© a cria√ß√£o de algoritmos avan√ßados.

</aside>

### Listas

Uma das principais formas de trabalhar com listas em Python √© usando os m√©todos de lista. Os m√©todos de lista s√£o fun√ß√µes especiais que nos permitem realizar tarefas comuns com listas, como adicionar, remover, modificar e procurar elementos.

Por exemplo, o m√©todo `append()` permite adicionar um novo elemento ao final de uma lista:

```python
minha_lista = [1, 2, 3]
minha_lista.append(4)
print(minha_lista) # [1, 2, 3, 4]

```

O m√©todo `remove()` permite remover um elemento espec√≠fico da lista:

```python
minha_lista = [1, 2, 3, 4]
minha_lista.remove(3)
print(minha_lista) # [1, 2, 4]

```

O m√©todo `sort()` permite classificar os elementos de uma lista em ordem crescente ou decrescente:

```python
minha_lista = [3, 1, 4, 2]
minha_lista.sort()
print(minha_lista) # [1, 2, 3, 4]

```

Listas s√£o √∫teis quando voc√™ precisa armazenar v√°rios objetos do mesmo tipo. Aqui est√£o alguns exemplos de usos comuns para listas no Python:

- Armazenar uma lista de nomes: `nomes = ['Jo√£o', 'Maria', 'Ana']`
- Armazenar uma lista de n√∫meros: `numeros = [1, 2, 3, 4, 5]`
- Armazenar uma lista de strings: `strings = ['Ol√°', 'mundo', '!']`
- Armazenar uma lista de objetos: `objetos = [obj_a, obj_b, obj_c]`
- Armazenar uma lista de listas: `listas = [[1, 2], [3, 4], [5, 6]]`
- Percorrer todos os elementos de uma lista:

```python
lista = [1, 2, 3]

for elemento in lista:
    print(elemento)

```

- Modificar elementos de uma lista:

```python
lista = [1, 2, 3]

lista[0] = 4
lista[1] = 5
lista[2] = 6

print(lista) # [4, 5, 6]

```

- Adicionar elementos a uma lista:

```python
lista = [1, 2, 3]

lista.append(4)
lista.append(5)
lista.append(6)

print(lista) # [1, 2, 3, 4, 5, 6]

```

Al√©m disso, √© poss√≠vel usar v√°rios outros m√©todos de lista para realizar tarefas com listas, como `pop()`, `reverse()`, `count()` e `index()`. Para obter mais informa√ß√µes sobre esses m√©todos, consulte a [documenta√ß√£o do Python](https://docs.python.org/3/tutorial/datastructures.html).

### Tuplas

Tuplas s√£o √∫teis para armazenar dados que n√£o devem ser alterados. Por exemplo, imagine que voc√™ tem um conjunto de dados que representam as coordenadas de um lugar, como latitude e longitude. Uma tupla √© uma estrutura de dados ideal para armazenar esses dados, pois uma vez criadas, as tuplas n√£o podem ser alteradas.

Uma das principais formas de trabalhar com tuplas em Python √© usando os m√©todos de tupla. Os m√©todos de tupla s√£o fun√ß√µes especiais que nos permitem realizar tarefas comuns com tuplas, como acessar, contar e pesquisar elementos.

Aqui est√£o alguns exemplos de usos comuns para tuplas no Python:

- Armazenar uma tupla de nomes: `nomes = ('Jo√£o', 'Maria', 'Ana')`
- Armazenar uma tupla de n√∫meros: `numeros = (1, 2, 3, 4, 5)`
- Armazenar uma tupla de strings: `strings = ('Ol√°', 'mundo', '!')`
- Armazenar uma tupla de objetos: `objetos = (obj_a, obj_b, obj_c)`
- Armazenar uma tupla de tuplas: `tuplas = ((1, 2), (3, 4), (5, 6))`
- Percorrer todos os elementos de uma tupla:

```python
tupla = (1, 2, 3)

for elemento in tupla:
    print(elemento)

```

- Modificar elementos de uma tupla:

```python
tupla = (1, 2, 3)

nova_tupla = (4, 5, 6)

tupla = nova_tupla

print(tupla) # (4, 5, 6)

```

- Desempacotar uma tupla:

```python
tupla = (1, 2, 3)

a, b, c = tupla

print(a) # 1
print(b) # 2
print(c) # 3

```

Outra situa√ß√£o em que as tuplas s√£o √∫teis √© quando voc√™ precisa passar v√°rios par√¢metros para uma fun√ß√£o. Como as tuplas s√£o imut√°veis, o valor dos par√¢metros n√£o pode ser alterado accidentalmente:

```python
# Uma fun√ß√£o que calcula a m√©dia de tr√™s n√∫meros
def media(a, b, c):
    return (a + b + c) / 3

# Uma tupla com os tr√™s n√∫meros
numeros = (1, 2, 3)

# Chamando a fun√ß√£o "media" e passando a tupla como par√¢metro
resultado = media(*numeros)

print(resultado) # 2.0

```

Al√©m disso, as tuplas s√£o √∫teis para armazenar conjuntos de dados relacionados, como um nome e uma idade. Por exemplo, voc√™ pode criar uma tupla contendo um nome e uma idade e armazen√°-la em uma lista para acessar facilmente os dados:

```python
# Uma tupla contendo o nome e a idade de uma pessoa
pessoa = ("Jo√£o", 25)

# Uma lista de tuplas contendo o nome e a idade de v√°rias pessoas
lista_pessoas = [("Jo√£o", 25), ("Maria", 20), ("Ana", 30)]

# Acessando os dados de uma tupla espec√≠fica
nome = lista_pessoas[0][0]
idade = lista_pessoas[0][1]

print(f"{nome} tem {idade} anos.") # Jo√£o tem 25 anos.

```

Por fim, as tuplas tamb√©m s√£o √∫teis para criar dicion√°rios em que as chaves s√£o tuplas. Isso pode ser √∫til se voc√™ precisar armazenar um conjunto de dados relacionados, como as coordenadas de uma cidade:

```python
cidade = {
    (10.0, 15.0): 'Rio de Janeiro',
    (20.0, 25.0): 'S√£o Paulo',
    (30.0, 35.0): 'Bel√©m'
}

## Agora, voc√™ pode facilmente recuperar o nome da cidade usando as coordenadas:

# Recuperando o nome da cidade usando as coordenadas
coordenadas = (10.0, 15.0)

nome_cidade = cidade[coordenadas]

print(nome_cidade) # Rio de Janeiro
```

Al√©m disso, √© poss√≠vel usar v√°rios outros m√©todos de tupla para realizar tarefas com tuplas, como  `index()` ,`count()` ,`len()`, `sum()` e `max()`. Para obter mais informa√ß√µes sobre esses m√©todos, consulte a [documenta√ß√£o do Python](https://docs.python.org/3/tutorial/datastructures.html).

### Refer√™ncias

[5. Data Structures](https://docs.python.org/3/tutorial/datastructures.html)

[3.11.1 Documentation](https://docs.python.org/pt-br/3/index.html)